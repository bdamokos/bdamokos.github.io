<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Speedometer</title>
    <style>
      :root {
        --bg: #101418;
        --panel: #1a222c;
        --text: #f2f6fa;
        --muted: #90a2b4;
        --accent: #36d18e;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        font-family: "Avenir Next", "Segoe UI", sans-serif;
        background: radial-gradient(circle at top, #1c2733 0%, var(--bg) 55%);
        color: var(--text);
      }

      main {
        width: min(92vw, 420px);
        padding: 24px;
        border-radius: 18px;
        background: linear-gradient(180deg, #22303d 0%, var(--panel) 100%);
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.32);
        text-align: center;
      }

      h1 {
        margin: 0 0 8px;
        font-size: 1rem;
        color: var(--muted);
        font-weight: 600;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      .speed {
        font-size: clamp(3rem, 17vw, 5rem);
        font-weight: 700;
        line-height: 1;
      }

      .speed span {
        color: var(--accent);
      }

      .unit {
        margin-top: 4px;
        font-size: 1rem;
        color: var(--muted);
      }

      .secondary {
        margin-top: 10px;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .status {
        margin: 12px 0 10px;
        min-height: 1.3em;
        font-size: 0.9rem;
        color: var(--muted);
      }

      button {
        border: 0;
        border-radius: 10px;
        padding: 10px 16px;
        background: var(--accent);
        color: #062514;
        font-size: 0.95rem;
        font-weight: 700;
      }

      button:disabled {
        opacity: 0.65;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Current Speed</h1>
      <div class="speed"><span id="kmh">0</span></div>
      <div class="unit">km/h</div>
      <div class="secondary"><span id="mph">0</span> mph</div>
      <p class="status" id="status">Starting GPS...</p>
      <button id="start" type="button">Retry GPS / Enable Motion</button>
    </main>

    <script>
      const kmhEl = document.getElementById("kmh");
      const mphEl = document.getElementById("mph");
      const statusEl = document.getElementById("status");
      const startBtn = document.getElementById("start");

      let prevPos = null;
      let prevTime = 0;
      let watchId = null;
      let displayMps = 0;
      let targetMps = 0;
      let rafId = null;
      let gpsStartedAt = 0;
      let startupSamples = [];
      let lastStartFromUserGesture = false;
      let motionFallbackActive = false;
      let motionPrevTs = 0;
      let motionMps = 0;

      const MAX_REASONABLE_MPS = 80;
      const STARTUP_WARMUP_MS = 3000;
      const MOTION_NOISE_MPS2 = 0.35;
      const MOTION_MAX_MPS = 35;
      const MOTION_DAMPING_PER_SEC = 0.55;

      function toRad(deg) {
        return (deg * Math.PI) / 180;
      }

      function haversineMeters(a, b) {
        const R = 6371000;
        const dLat = toRad(b.latitude - a.latitude);
        const dLon = toRad(b.longitude - a.longitude);
        const lat1 = toRad(a.latitude);
        const lat2 = toRad(b.latitude);
        const h =
          Math.sin(dLat / 2) ** 2 +
          Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
        return 2 * R * Math.asin(Math.sqrt(h));
      }

      function updateSpeed(mps) {
        const safeMps = Number.isFinite(mps) && mps > 0 ? mps : 0;
        const kmh = safeMps * 3.6;
        const mph = safeMps * 2.236936;
        kmhEl.textContent = String(Math.round(kmh));
        mphEl.textContent = String(Math.round(mph));
      }

      function animateSpeed() {
        const delta = targetMps - displayMps;
        if (Math.abs(delta) < 0.02) {
          displayMps = targetMps;
          updateSpeed(displayMps);
          rafId = null;
          return;
        }
        displayMps += delta * 0.35;
        updateSpeed(displayMps);
        rafId = requestAnimationFrame(animateSpeed);
      }

      function setSpeed(mps) {
        targetMps = Math.min(MAX_REASONABLE_MPS, Math.max(0, mps || 0));
        if (rafId === null) rafId = requestAnimationFrame(animateSpeed);
      }

      function getStartupSpeed(speedMps) {
        startupSamples.push(speedMps);
        if (startupSamples.length > 5) startupSamples.shift();
        const sorted = startupSamples.slice().sort((a, b) => a - b);
        return sorted[Math.floor(sorted.length / 2)] || 0;
      }

      function stopMotionFallback() {
        if (!motionFallbackActive) return;
        window.removeEventListener("devicemotion", onDeviceMotion);
        motionFallbackActive = false;
        motionPrevTs = 0;
        motionMps = 0;
      }

      function getMotionMagnitude(ev) {
        const use = ev.acceleration || ev.accelerationIncludingGravity;
        if (!use) return null;
        const x = Number.isFinite(use.x) ? use.x : 0;
        const y = Number.isFinite(use.y) ? use.y : 0;
        const z = Number.isFinite(use.z) ? use.z : 0;
        if (!Number.isFinite(x + y + z)) return null;
        const mag = Math.hypot(x, y, z);
        if (ev.acceleration) return mag;
        // Fallback when only gravity-including acceleration is available.
        return Math.max(0, Math.abs(mag - 9.81));
      }

      function onDeviceMotion(ev) {
        if (!motionFallbackActive) return;
        const ts = Number.isFinite(ev.timeStamp) ? ev.timeStamp : performance.now();
        if (!motionPrevTs) {
          motionPrevTs = ts;
          return;
        }
        const dt = (ts - motionPrevTs) / 1000;
        motionPrevTs = ts;
        if (!(dt > 0 && dt < 0.5)) return;

        const accelMag = getMotionMagnitude(ev);
        if (accelMag == null) return;
        const linearAccel = Math.max(0, accelMag - MOTION_NOISE_MPS2);

        motionMps += linearAccel * dt;
        motionMps *= Math.pow(MOTION_DAMPING_PER_SEC, dt);
        motionMps = Math.max(0, Math.min(MOTION_MAX_MPS, motionMps));
        if (motionMps < 0.5) motionMps = 0;
        setSpeed(motionMps);
      }

      async function maybeStartMotionFallback(fromUserGesture, reasonText) {
        if (motionFallbackActive) return true;
        if (typeof DeviceMotionEvent === "undefined") {
          statusEl.textContent = `${reasonText} Motion fallback is not supported on this device.`;
          return false;
        }

        const hasPermissionApi =
          typeof DeviceMotionEvent.requestPermission === "function";
        if (hasPermissionApi) {
          if (!fromUserGesture) {
            statusEl.textContent =
              `${reasonText} Tap the button to allow motion fallback.`;
            return false;
          }
          try {
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission !== "granted") {
              statusEl.textContent =
                `${reasonText} Motion permission was denied.`;
              return false;
            }
          } catch {
            statusEl.textContent =
              `${reasonText} Could not enable motion fallback.`;
            return false;
          }
        }

        motionPrevTs = 0;
        motionMps = 0;
        motionFallbackActive = true;
        window.addEventListener("devicemotion", onDeviceMotion);
        statusEl.textContent = "GPS unavailable. Using motion estimate (rough).";
        return true;
      }

      function onPosition(pos) {
        stopMotionFallback();
        statusEl.textContent = "GPS active";
        startBtn.disabled = false;

        const now = pos.timestamp;
        const gpsMps =
          Number.isFinite(pos.coords.speed) && pos.coords.speed >= 0
            ? pos.coords.speed
            : null;
        let calcMps = null;
        const accuracy = Number.isFinite(pos.coords.accuracy)
          ? pos.coords.accuracy
          : 999;

        // Derived speed is often more responsive on iOS than coords.speed.
        if (prevPos && prevTime) {
          const dt = (now - prevTime) / 1000;
          if (dt > 0.8 && dt < 4) {
            const meters = haversineMeters(prevPos, pos.coords);
            calcMps = meters / dt;
          }
        }

        const inWarmup = now - gpsStartedAt < STARTUP_WARMUP_MS;
        let mps = gpsMps ?? 0;

        if (!inWarmup && calcMps != null && accuracy <= 40) {
          mps = calcMps;
        }

        if (accuracy > 120) {
          // Ignore very noisy fixes that cause big spikes.
          mps = gpsMps ?? 0;
        }
        mps = Math.min(MAX_REASONABLE_MPS, Math.max(0, mps));
        if (mps < 1.2) mps = 0;

        if (inWarmup) {
          setSpeed(getStartupSpeed(mps));
        } else {
          setSpeed(mps);
        }
        prevPos = pos.coords;
        prevTime = now;
      }

      function onError(err) {
        if (err.code === 1) {
          void maybeStartMotionFallback(
            lastStartFromUserGesture,
            "Location access denied."
          );
          startBtn.disabled = false;
          return;
        }
        if (err.code === 2) {
          void maybeStartMotionFallback(
            lastStartFromUserGesture,
            "Location unavailable."
          );
          startBtn.disabled = false;
          return;
        }
        if (err.code === 3) {
          void maybeStartMotionFallback(
            lastStartFromUserGesture,
            "Location timed out."
          );
          startBtn.disabled = false;
          return;
        }
        void maybeStartMotionFallback(
          lastStartFromUserGesture,
          "Unable to read GPS."
        );
        startBtn.disabled = false;
      }

      function startGps(fromUserGesture = false) {
        lastStartFromUserGesture = fromUserGesture;
        if (!("geolocation" in navigator)) {
          void maybeStartMotionFallback(
            fromUserGesture,
            "Geolocation is not supported in this browser."
          );
          startBtn.disabled = false;
          return;
        }

        if (location.protocol === "file:") {
          statusEl.textContent =
            "Safari blocks GPS from local files. Open this page via HTTPS.";
          startBtn.disabled = false;
          return;
        }

        stopMotionFallback();
        statusEl.textContent = "Requesting GPS permission...";
        startBtn.disabled = true;

        if (watchId !== null) {
          navigator.geolocation.clearWatch(watchId);
        }

        prevPos = null;
        prevTime = 0;
        gpsStartedAt = Date.now();
        startupSamples = [];

        watchId = navigator.geolocation.watchPosition(onPosition, onError, {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 5000
        });
      }

      startBtn.addEventListener("click", () => {
        startGps(true);
      });

      const isLocalhost =
        location.hostname === "localhost" || location.hostname === "127.0.0.1";
      window.addEventListener("load", () => {
        startGps(false);
        if (
          "serviceWorker" in navigator &&
          (location.protocol === "https:" || isLocalhost)
        ) {
          navigator.serviceWorker.register("./sw.js").catch(() => {
            // Page works without SW; this only affects offline capability.
          });
        }
      });
    </script>
  </body>
</html>
